// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpdateLdapServerXo update ldap server xo
//
// swagger:model UpdateLdapServerXo
type UpdateLdapServerXo struct {

	// The password to bind with. Required if authScheme other than none.
	// Required: true
	AuthPassword *string `json:"authPassword"`

	// The SASL realm to bind to. Required if authScheme is CRAM_MD5 or DIGEST_MD5
	// Example: example.com
	AuthRealm string `json:"authRealm,omitempty"`

	// Authentication scheme used for connecting to LDAP server
	// Required: true
	// Enum: [NONE SIMPLE DIGEST_MD5 CRAM_MD5]
	AuthScheme *string `json:"authScheme"`

	// This must be a fully qualified username if simple authentication is used. Required if authScheme other than none.
	AuthUsername string `json:"authUsername,omitempty"`

	// How long to wait before retrying
	// Required: true
	// Minimum: 0
	ConnectionRetryDelaySeconds *int32 `json:"connectionRetryDelaySeconds"`

	// How long to wait before timeout
	// Example: 1
	// Required: true
	// Maximum: 3600
	// Minimum: 1
	ConnectionTimeoutSeconds *int32 `json:"connectionTimeoutSeconds"`

	// The relative DN where group objects are found (e.g. ou=Group). This value will have the Search base DN value appended to form the full Group search base DN.
	// Example: ou=Group
	GroupBaseDn string `json:"groupBaseDn,omitempty"`

	// This field specifies the attribute of the Object class that defines the Group ID. Required if groupType is static
	// Example: cn
	// Max Length: 0
	// Min Length: 0
	GroupIDAttribute *string `json:"groupIdAttribute,omitempty"`

	// LDAP attribute containing the usernames for the group. Required if groupType is static
	// Example: memberUid
	// Max Length: 0
	// Min Length: 0
	GroupMemberAttribute *string `json:"groupMemberAttribute,omitempty"`

	// The format of user ID stored in the group member attribute. Required if groupType is static
	// Example: uid=${username},ou=people,dc=example,dc=com
	// Max Length: 0
	// Min Length: 0
	GroupMemberFormat *string `json:"groupMemberFormat,omitempty"`

	// LDAP class for group objects. Required if groupType is static
	// Example: posixGroup
	// Max Length: 0
	// Min Length: 0
	GroupObjectClass *string `json:"groupObjectClass,omitempty"`

	// Are groups located in structures below the group base DN
	GroupSubtree bool `json:"groupSubtree,omitempty"`

	// Defines a type of groups used: static (a group contains a list of users) or dynamic (a user contains a list of groups). Required if ldapGroupsAsRoles is true.
	// Required: true
	// Enum: [static dynamic]
	GroupType *string `json:"groupType"`

	// LDAP server connection hostname
	// Required: true
	Host *string `json:"host"`

	// LDAP server ID
	ID string `json:"id,omitempty"`

	// Denotes whether LDAP assigned roles are used as Nexus Repository Manager roles
	LdapGroupsAsRoles bool `json:"ldapGroupsAsRoles,omitempty"`

	// How many retry attempts
	// Required: true
	// Minimum: 0
	MaxIncidentsCount *int32 `json:"maxIncidentsCount"`

	// LDAP server name
	// Required: true
	Name *string `json:"name"`

	// LDAP server connection port to use
	// Example: 636
	// Required: true
	Port *int32 `json:"port"`

	// LDAP server connection Protocol to use
	// Required: true
	// Enum: [ldap ldaps]
	Protocol *string `json:"protocol"`

	// LDAP location to be added to the connection URL
	// Example: dc=example,dc=com
	// Required: true
	SearchBase *string `json:"searchBase"`

	// Whether to use certificates stored in Nexus Repository Manager's truststore
	UseTrustStore bool `json:"useTrustStore,omitempty"`

	// The relative DN where user objects are found (e.g. ou=people). This value will have the Search base DN value appended to form the full User search base DN.
	// Example: ou=people
	UserBaseDn string `json:"userBaseDn,omitempty"`

	// This is used to find an email address given the user ID
	// Example: mail
	UserEmailAddressAttribute string `json:"userEmailAddressAttribute,omitempty"`

	// This is used to find a user given its user ID
	// Example: uid
	UserIDAttribute string `json:"userIdAttribute,omitempty"`

	// LDAP search filter to limit user search
	// Example: (|(mail=*@example.com)(uid=dom*))
	UserLdapFilter string `json:"userLdapFilter,omitempty"`

	// Set this to the attribute used to store the attribute which holds groups DN in the user object. Required if groupType is dynamic
	// Example: memberOf
	// Max Length: 0
	// Min Length: 0
	UserMemberOfAttribute *string `json:"userMemberOfAttribute,omitempty"`

	// LDAP class for user objects
	// Example: inetOrgPerson
	UserObjectClass string `json:"userObjectClass,omitempty"`

	// If this field is blank the user will be authenticated against a bind with the LDAP server
	UserPasswordAttribute string `json:"userPasswordAttribute,omitempty"`

	// This is used to find a real name given the user ID
	// Example: cn
	UserRealNameAttribute string `json:"userRealNameAttribute,omitempty"`

	// Are users located in structures below the user base DN?
	UserSubtree bool `json:"userSubtree,omitempty"`
}

// Validate validates this update ldap server xo
func (m *UpdateLdapServerXo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthScheme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectionRetryDelaySeconds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectionTimeoutSeconds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupIDAttribute(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupMemberAttribute(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupMemberFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupObjectClass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxIncidentsCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSearchBase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserMemberOfAttribute(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateLdapServerXo) validateAuthPassword(formats strfmt.Registry) error {

	if err := validate.Required("authPassword", "body", m.AuthPassword); err != nil {
		return err
	}

	return nil
}

var updateLdapServerXoTypeAuthSchemePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NONE","SIMPLE","DIGEST_MD5","CRAM_MD5"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateLdapServerXoTypeAuthSchemePropEnum = append(updateLdapServerXoTypeAuthSchemePropEnum, v)
	}
}

const (

	// UpdateLdapServerXoAuthSchemeNONE captures enum value "NONE"
	UpdateLdapServerXoAuthSchemeNONE string = "NONE"

	// UpdateLdapServerXoAuthSchemeSIMPLE captures enum value "SIMPLE"
	UpdateLdapServerXoAuthSchemeSIMPLE string = "SIMPLE"

	// UpdateLdapServerXoAuthSchemeDIGESTMD5 captures enum value "DIGEST_MD5"
	UpdateLdapServerXoAuthSchemeDIGESTMD5 string = "DIGEST_MD5"

	// UpdateLdapServerXoAuthSchemeCRAMMD5 captures enum value "CRAM_MD5"
	UpdateLdapServerXoAuthSchemeCRAMMD5 string = "CRAM_MD5"
)

// prop value enum
func (m *UpdateLdapServerXo) validateAuthSchemeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateLdapServerXoTypeAuthSchemePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdateLdapServerXo) validateAuthScheme(formats strfmt.Registry) error {

	if err := validate.Required("authScheme", "body", m.AuthScheme); err != nil {
		return err
	}

	// value enum
	if err := m.validateAuthSchemeEnum("authScheme", "body", *m.AuthScheme); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateConnectionRetryDelaySeconds(formats strfmt.Registry) error {

	if err := validate.Required("connectionRetryDelaySeconds", "body", m.ConnectionRetryDelaySeconds); err != nil {
		return err
	}

	if err := validate.MinimumInt("connectionRetryDelaySeconds", "body", int64(*m.ConnectionRetryDelaySeconds), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateConnectionTimeoutSeconds(formats strfmt.Registry) error {

	if err := validate.Required("connectionTimeoutSeconds", "body", m.ConnectionTimeoutSeconds); err != nil {
		return err
	}

	if err := validate.MinimumInt("connectionTimeoutSeconds", "body", int64(*m.ConnectionTimeoutSeconds), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("connectionTimeoutSeconds", "body", int64(*m.ConnectionTimeoutSeconds), 3600, false); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateGroupIDAttribute(formats strfmt.Registry) error {
	if swag.IsZero(m.GroupIDAttribute) { // not required
		return nil
	}

	if err := validate.MinLength("groupIdAttribute", "body", *m.GroupIDAttribute, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("groupIdAttribute", "body", *m.GroupIDAttribute, 0); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateGroupMemberAttribute(formats strfmt.Registry) error {
	if swag.IsZero(m.GroupMemberAttribute) { // not required
		return nil
	}

	if err := validate.MinLength("groupMemberAttribute", "body", *m.GroupMemberAttribute, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("groupMemberAttribute", "body", *m.GroupMemberAttribute, 0); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateGroupMemberFormat(formats strfmt.Registry) error {
	if swag.IsZero(m.GroupMemberFormat) { // not required
		return nil
	}

	if err := validate.MinLength("groupMemberFormat", "body", *m.GroupMemberFormat, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("groupMemberFormat", "body", *m.GroupMemberFormat, 0); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateGroupObjectClass(formats strfmt.Registry) error {
	if swag.IsZero(m.GroupObjectClass) { // not required
		return nil
	}

	if err := validate.MinLength("groupObjectClass", "body", *m.GroupObjectClass, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("groupObjectClass", "body", *m.GroupObjectClass, 0); err != nil {
		return err
	}

	return nil
}

var updateLdapServerXoTypeGroupTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["static","dynamic"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateLdapServerXoTypeGroupTypePropEnum = append(updateLdapServerXoTypeGroupTypePropEnum, v)
	}
}

const (

	// UpdateLdapServerXoGroupTypeStatic captures enum value "static"
	UpdateLdapServerXoGroupTypeStatic string = "static"

	// UpdateLdapServerXoGroupTypeDynamic captures enum value "dynamic"
	UpdateLdapServerXoGroupTypeDynamic string = "dynamic"
)

// prop value enum
func (m *UpdateLdapServerXo) validateGroupTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateLdapServerXoTypeGroupTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdateLdapServerXo) validateGroupType(formats strfmt.Registry) error {

	if err := validate.Required("groupType", "body", m.GroupType); err != nil {
		return err
	}

	// value enum
	if err := m.validateGroupTypeEnum("groupType", "body", *m.GroupType); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateHost(formats strfmt.Registry) error {

	if err := validate.Required("host", "body", m.Host); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateMaxIncidentsCount(formats strfmt.Registry) error {

	if err := validate.Required("maxIncidentsCount", "body", m.MaxIncidentsCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("maxIncidentsCount", "body", int64(*m.MaxIncidentsCount), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validatePort(formats strfmt.Registry) error {

	if err := validate.Required("port", "body", m.Port); err != nil {
		return err
	}

	return nil
}

var updateLdapServerXoTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ldap","ldaps"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateLdapServerXoTypeProtocolPropEnum = append(updateLdapServerXoTypeProtocolPropEnum, v)
	}
}

const (

	// UpdateLdapServerXoProtocolLdap captures enum value "ldap"
	UpdateLdapServerXoProtocolLdap string = "ldap"

	// UpdateLdapServerXoProtocolLdaps captures enum value "ldaps"
	UpdateLdapServerXoProtocolLdaps string = "ldaps"
)

// prop value enum
func (m *UpdateLdapServerXo) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateLdapServerXoTypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdateLdapServerXo) validateProtocol(formats strfmt.Registry) error {

	if err := validate.Required("protocol", "body", m.Protocol); err != nil {
		return err
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateSearchBase(formats strfmt.Registry) error {

	if err := validate.Required("searchBase", "body", m.SearchBase); err != nil {
		return err
	}

	return nil
}

func (m *UpdateLdapServerXo) validateUserMemberOfAttribute(formats strfmt.Registry) error {
	if swag.IsZero(m.UserMemberOfAttribute) { // not required
		return nil
	}

	if err := validate.MinLength("userMemberOfAttribute", "body", *m.UserMemberOfAttribute, 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userMemberOfAttribute", "body", *m.UserMemberOfAttribute, 0); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this update ldap server xo based on context it is used
func (m *UpdateLdapServerXo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *UpdateLdapServerXo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpdateLdapServerXo) UnmarshalBinary(b []byte) error {
	var res UpdateLdapServerXo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
